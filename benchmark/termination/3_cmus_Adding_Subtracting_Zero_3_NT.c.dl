/* */


/*(Start())@6 路 ("pos"=0)@7 路 ("rc"=_)@8 路 ("size"=_)@9 路 ("flag"=0)@10 路 ("errno"=0)@11 路 ((["size"<=0]@12 路 ("size"<=0)@13 路 (Return(0))@14) \/ (["size">0]@15 路 ("size">0)@16 路 ((["size">65536]@17 路 ("size">65536)@18 路 (Return(0))@19) \/ (["size"<=65536]@20 路 ("size"<=65536)@21 路 ((["pos">="size"]@22 路 ("pos">="size")@23 路 (Return(0))@24) \/ (["pos"<"size"]@25 路 ("pos"<"size")@26 路 ((["rc">0]@27 路 ("rc">0)@28 路 ("size"="pos")@29 路 (Return(0))@30) \/ (["rc"<=0]@31 路 ("rc"<=0)@32 路 ((("size"-"pos")>=1)@33)^w))))))))*/

flow(6,7).
flow(7,8).
flow(8,9).
flow(9,10).
flow(10,11).
flow(12,13).
flow(13,14).
flow(14,14).
flow(15,16).
flow(17,18).
flow(18,19).
flow(19,19).
flow(20,21).
flow(22,23).
flow(23,24).
flow(24,24).
flow(25,26).
flow(27,28).
flow(28,29).
flow(29,30).
flow(30,30).
flow(31,32).
flow(32,33).
flow(33,33).
Start(6).
State(6).
State(7).
LtEq("rc",8,0).
Gt("rc",8,0).
State(8).
GtEqVar("pos",9,"size").
LtVar("pos",9,"size").
LtEq("size",9,65536).
Gt("size",9,65536).
LtEq("size",9,0).
Gt("size",9,0).
State(9).
State(10).
State(12).
LtEq("size",13,0).
LtEq("size",13,65536).
State(13).
Return(0,14).
State(14).
State(11).
State(15).
Gt("size",16,0).
State(17).
Gt("size",18,65536).
Gt("size",18,0).
State(18).
Return(0,19).
State(19).
State(16).
State(20).
LtEq("size",21,65536).
State(22).
GtEqVar("pos",23,"size").
State(23).
Return(0,24).
State(24).
State(21).
State(25).
LtVar("pos",26,"size").
State(27).
Gt("rc",28,0).
State(28).
LtEq("size",29,0).
GtEqVar("pos",29,"size").
LtEq("size",29,65536).
State(29).
Return(0,30).
State(30).
State(26).
State(31).
LtEq("rc",32,0).
State(32).
State(33).
control_flow(11,12) :- LtEqD("size",11,0).
control_flow(11,15) :- GtD("size",11,0).
control_flow(16,17) :- GtD("size",16,65536).
control_flow(16,20) :- LtEqD("size",16,65536).
control_flow(21,22) :- GtEqVarD("pos",21,"size").
control_flow(21,25) :- LtVarD("pos",21,"size").
control_flow(26,27) :- GtD("rc",26,0).
control_flow(26,31) :- LtEqD("rc",26,0).
/* */


//AF(EXIT())
.decl Start(x:number)
.decl State(x:number)
.decl flow(x:number,y:number)
.decl control_flow(x:number,y:number)
.decl transFlow(x:number,y:number)
.decl NotTotal(loc:number)
.decl Return(n0:number,n1:number)
.decl LtVar(x:symbol,loc:number,y:symbol)
.decl GtEqVar(x:symbol,loc:number,y:symbol)
.decl Gt(x:symbol,loc:number,n:number)
.decl LtEq(x:symbol,loc:number,n:number)
.decl LtVarD(x:symbol,loc:number,y:symbol)
.decl GtEqVarD(x:symbol,loc:number,y:symbol)
.decl GtD(x:symbol,loc:number,n:number)
.decl LtEqD(x:symbol,loc:number,n:number)
.decl EXITPred(loc:number)
.decl AF_EXITPred_T(interm_state:number,loc:number)
.decl AF_EXITPred_S(loc:number)
.decl AF_EXITPred(loc:number)
.decl AF_EXITPred_Final(loc:number)transFlow(x,y) :- control_flow(x,y).
transFlow(x,z) :- control_flow(x,y), transFlow(y,z).
NotTotal(loc) :- State(loc), !control_flow(loc,_).
NotTotal(loc) :- NotTotal(locI), control_flow(loc,locI).
control_flow(x,y) :- flow(x,y).
LtVarD(x,loc,n) :- LtVar(x,loc,n).
LtVarD(x,loc,n) :- LtVarD(x,locI,n), control_flow(locI,loc), !LtVar(x,loc,n), !GtEqVar(x,loc,n).
GtEqVarD(x,loc,n) :- GtEqVar(x,loc,n).
GtEqVarD(x,loc,n) :- GtEqVarD(x,locI,n), control_flow(locI,loc), !GtEqVar(x,loc,n), !LtVar(x,loc,n).
GtD(x,loc,n) :- Gt(x,loc,n).
GtD(x,loc,n) :- GtD(x,locI,n), control_flow(locI,loc), !Gt(x,loc,n), !LtEq(x,loc,n).
LtEqD(x,loc,n) :- LtEq(x,loc,n).
LtEqD(x,loc,n) :- LtEqD(x,locI,n), control_flow(locI,loc), !LtEq(x,loc,n), !Gt(x,loc,n).
EXITPred(loc) :- Return(_,loc).
AF_EXITPred_T(interm_state,loc) :- AF_EXITPred_T(tempOne,loc), !EXITPred(tempOne), control_flow(tempOne,interm_state).
AF_EXITPred_T(interm_state,loc) :- !EXITPred(loc), control_flow(loc,interm_state).
AF_EXITPred_S(loc) :- !EXITPred(loc), control_flow(loc,tempOne), AF_EXITPred_S(tempOne).
AF_EXITPred_S(loc) :- AF_EXITPred_T(loc,loc).
AF_EXITPred(loc) :- State(loc), !AF_EXITPred_S(loc).
AF_EXITPred_Final(loc) :- Start(loc), AF_EXITPred(loc), !NotTotal(loc).
.output LtVar
.output GtEqVar
.output Gt
.output LtEq
.output Start
.output State
.output flow
.output Return
.output AF_EXITPred_Final(IO=stdout)

.output NotTotal(IO=stdout)

/* Other information 

//-- Facts for Procedure <__VERIFIER_nondet_int> 

//-- Facts for Procedure <main> 

Flow(26,0). //@71:1-73:5
Flow(23,7). //@93:5-94:1
Flow(14,25). //@81:5-81:12
Flow(25,22). //@81:12-81:12
Flow(25,24). //@81:12-81:12
Flow(24,15). //@81:12-83:9
Flow(22,23). //@81:12-93:5
Flow(21,14). //@91:9-81:5
Flow(19,21). //@84:9-91:9
Flow(16,18). //@84:13-84:13
Flow(16,20). //@84:13-84:13
Flow(20,17). //@84:13-88:17
Flow(18,19). //@84:13-84:9
Flow(17,7). //@88:17-94:1
Flow(15,16). //@83:9-84:13
Flow(9,14). //@79:5-81:5
Flow(5,12). //@79:9-79:9
Flow(5,13). //@79:9-79:9
Flow(13,6). //@79:9-80:9
Flow(12,11). //@79:9-79:22
Flow(11,8). //@79:22-79:22
Flow(11,10). //@79:22-79:22
Flow(10,6). //@79:22-80:9
Flow(8,9). //@79:22-79:5
Flow(6,7). //@80:9-94:1
Flow(4,5). //@78:5-79:9
Flow(3,4). //@77:5-78:5
Flow(2,3). //@76:5-77:5
Flow(1,2). //@74:5-76:5
Flow(0,1). //@73:5-74:5
Stmt_Decl(0,[IStore(&pos,0)]). // @73:5
Stmt_Decl(1,[ICall(_fun___VERIFIER_nondet_int,,n$17),IStore(&rc,n$17)]). // @74:5
Stmt_Decl(2,[ICall(_fun___VERIFIER_nondet_int,,n$16),IStore(&size,n$16)]). // @76:5
Stmt_Decl(3,[IStore(&flag,0)]). // @77:5
Stmt_Decl(4,[IStore(&errno,0)]). // @78:5
Stmt_Return(6,[IStore(&return,0)]). // @80:9
PruneNode(8,false,[Prune(!(n$13 > 65536), false)]). // @79:22
PruneNode(10,true,[Prune((n$13 > 65536), true)]). // @79:22
Stmt_BinaryOperatorStmt(11,GT,[ILoad(&size,n$13)]). // @79:22
PruneNode(12,false,[Prune(!(n$12 <= 0), false)]). // @79:9
PruneNode(13,true,[Prune((n$12 <= 0), true)]). // @79:9
Stmt_BinaryOperatorStmt(5,LE,[ILoad(&size,n$12)]). // @79:9
Join(9,[]).  // @79:5
Stmt_Decl(15,[ILoad(&pos,n$7),ILoad(&size,n$8),ILoad(&pos,n$9),ICall(_fun_read,n$7,(n$8 - n$9),n$10),IStore(&rc,n$10)]). // @83:9
Stmt_Return(17,[IStore(&return,0)]). // @88:17
PruneNode(18,false,[Prune(!(n$4 < 0), false)]). // @84:13
PruneNode(20,true,[Prune((n$4 < 0), true)]). // @84:13
Stmt_BinaryOperatorStmt(16,LT,[ILoad(&rc,n$4)]). // @84:13
Join(19,[]).  // @84:9
Stmt_BinaryOperatorStmt(21,Assign,[ILoad(&pos,n$2),ILoad(&rc,n$3),IStore(&pos,(n$2 + n$3))]). // @91:9
PruneNode(22,false,[Prune(!(n$0 < n$1), false)]). // @81:12
PruneNode(24,true,[Prune((n$0 < n$1), true)]). // @81:12
Stmt_BinaryOperatorStmt(25,LT,[ILoad(&pos,n$0),ILoad(&size,n$1)]). // @81:12
Join(14,[]).  // @81:5
Stmt_Return(23,[IStore(&return,0)]). // @93:5
Exit(7).  // @94:1
Start(26). // @71:1
//-- Facts for Procedure <read> 

*/

