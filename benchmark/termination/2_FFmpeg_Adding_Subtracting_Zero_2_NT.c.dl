/*(Join())@1*/

flow(1,1).
State(1).

/*(Start())@18 · (n=_)@19 · (ptr=(ptr+n))@20 · (([ptr=13]@21 · (ptr=(ptr+1))@22 · (n=(n+1))@23 · (([ptr=10]@24 · (n=(n+1))@25 · (Return(0))@26) \/ ([(ptr!=10)]@27 · (Return(0))@28))) \/ ([(ptr!=13)]@29 · (([ptr=10]@30 · (n=(n+1))@31 · (Return(0))@32) \/ ([(ptr!=10)]@33 · (Return(0))@34))))*/

flow(18,19).
flow(19,20).
flow(26,26).
flow(28,28).
flow(32,32).
flow(34,34).
Start(18).
Eq("ptr",18,13).
Eq("ptr",18,10).
NotEq("ptr",18,13).
NotEq("ptr",18,10).
State(18).
State(19).
State(21).
State(22).
State(24).
State(25).
Return(0,26).
State(26).
State(23).
State(27).
Return(0,28).
State(28).
State(20).
State(30).
State(31).
Return(0,32).
State(32).
State(29).
State(33).
Return(0,34).
State(34).
control_flow(20,21) :- EqD("ptr",20,13).
control_flow(21,22) :- EqD("ptr",20,13).
control_flow(22,23) :- EqD("ptr",20,13).
control_flow(23,24) :- EqD("ptr",20,13), EqD("ptr",23,10).
control_flow(24,25) :- EqD("ptr",20,13), EqD("ptr",23,10).
control_flow(25,26) :- EqD("ptr",20,13), EqD("ptr",23,10).
control_flow(23,27) :- EqD("ptr",20,13), NotEqD("ptr",23,10).
control_flow(27,28) :- EqD("ptr",20,13), NotEqD("ptr",23,10).
control_flow(20,29) :- NotEqD("ptr",20,13).
control_flow(29,30) :- NotEqD("ptr",20,13), EqD("ptr",29,10).
control_flow(30,31) :- NotEqD("ptr",20,13), EqD("ptr",29,10).
control_flow(31,32) :- NotEqD("ptr",20,13), EqD("ptr",29,10).
control_flow(29,33) :- NotEqD("ptr",20,13), NotEqD("ptr",29,10).
control_flow(33,34) :- NotEqD("ptr",20,13), NotEqD("ptr",29,10).
/*(Start())@41 · (b=_)@42 · (end=_)@43 · (([b<0]@44 · (Return(0))@45) \/ ([b>=0]@46 · (([end<0]@47 · (Return(0))@48) \/ ([end>=0]@49 · (((Return(0))@50) \/ ((([inc>0]@51 · [b<end]@52 · (end=b)@53 · (Return(0))@54) \/ ([inc<=0]@55 · ([b<end]@56 · ((end-b)>0)@57)^w))))))))*/

flow(41,42).
flow(42,43).
flow(45,45).
flow(48,48).
flow(50,50).
flow(54,54).
flow(57,57).
flow(57,56).
Start(41).
Lt("b",41,0).
Lt("end",41,0).
Gt("inc",41,0).
GtEq("b",41,0).
GtEq("end",41,0).
LtEq("inc",41,0). // delete this line 
LtVar("b",41,"end").
State(41).
State(42).
State(44).
Return(0,45).
State(45).
State(43).
State(47).
Return(0,48).
State(48).
State(46).
Return(0,50).
State(50).
State(51).
State(52).
GtEq("end",53,0).
State(53).
Return(0,54).
State(54).
State(49).
State(55).
State(56).
State(57).
control_flow(43,44) :- LtD("b",43,0).
control_flow(44,45) :- LtD("b",43,0).
control_flow(43,46) :- GtEqD("b",43,0).
control_flow(46,47) :- GtEqD("b",43,0), LtD("end",46,0).
control_flow(47,48) :- GtEqD("b",43,0), LtD("end",46,0).
control_flow(46,49) :- GtEqD("b",43,0), GtEqD("end",46,0).
control_flow(49,50) :- GtEqD("b",43,0), GtEqD("end",46,0).
control_flow(49,51) :- GtEqD("b",43,0), GtEqD("end",46,0), GtD("inc",49,0).
control_flow(51,52) :- GtEqD("b",43,0), GtEqD("end",46,0), GtD("inc",49,0), LtVarD("b",51,"end").
control_flow(52,53) :- GtEqD("b",43,0), GtEqD("end",46,0), GtD("inc",49,0), LtVarD("b",51,"end").
control_flow(53,54) :- GtEqD("b",43,0), GtEqD("end",46,0), GtD("inc",49,0), LtVarD("b",51,"end").
control_flow(49,55) :- GtEqD("b",43,0), GtEqD("end",46,0), LtEqD("inc",49,0).
control_flow(55,56) :- GtEqD("b",43,0), GtEqD("end",46,0), LtEqD("inc",49,0), LtVarD("b",55,"end").
control_flow(56,57) :- GtEqD("b",43,0), GtEqD("end",46,0), LtEqD("inc",49,0), LtVarD("b",55,"end").
//AF(EXIT())
.decl Start(x:number)
.decl State(x:number)
.decl flow(x:number,y:number)
.decl control_flow(x:number,y:number)
.decl transFlow(x:number,y:number)
.decl NotTotal(loc:number)
.decl Return(n0:number,n1:number)
.decl GtEqVar(x:symbol,loc:number,y:symbol)
.decl LtVar(x:symbol,loc:number,y:symbol)
.decl LtEq(x:symbol,loc:number,n:number)
.decl GtEq(x:symbol,loc:number,n:number)
.decl Gt(x:symbol,loc:number,n:number)
.decl Lt(x:symbol,loc:number,n:number)
.decl NotEq(x:symbol,loc:number,n:number)
.decl Eq(x:symbol,loc:number,n:number)
.decl LtEqD(x:symbol,loc:number,n:number)
.decl LtVarD(x:symbol,loc:number,y:symbol)
.decl GtD(x:symbol,loc:number,n:number)
.decl GtEqD(x:symbol,loc:number,n:number)
.decl LtD(x:symbol,loc:number,n:number)
.decl NotEqD(x:symbol,loc:number,n:number)
.decl EqD(x:symbol,loc:number,n:number)
.decl EXIT(loc:number)
.decl AF_EXIT_T(interm_state:number,loc:number)
.decl AF_EXIT_S(loc:number)
.decl AF_EXIT(loc:number)
.decl AF_EXIT_Final(loc:number)transFlow(x,y) :- control_flow(x,y).
transFlow(x,z) :- control_flow(x,y), transFlow(y,z).
NotTotal(loc) :- State(loc), !control_flow(loc,_).
NotTotal(loc) :- NotTotal(locI), control_flow(loc,locI).
control_flow(x,y) :- flow(x,y).
LtEqD(x,loc,n) :- LtEq(x,loc,n).
LtEqD(x,loc,n) :- LtEqD(x,locI,n), control_flow(locI,loc), !LtEq(x,loc,_), !Gt(x,loc,_).
LtVarD(x,loc,n) :- LtVar(x,loc,n).
LtVarD(x,loc,n) :- LtVarD(x,locI,n), control_flow(locI,loc), !LtVar(x,loc,_), !GtEqVar(x,loc,_).
GtD(x,loc,n) :- Gt(x,loc,n).
GtD(x,loc,n) :- GtD(x,locI,n), control_flow(locI,loc), !Gt(x,loc,_), !LtEq(x,loc,_).
GtEqD(x,loc,n) :- GtEq(x,loc,n).
GtEqD(x,loc,n) :- GtEqD(x,locI,n), control_flow(locI,loc), !GtEq(x,loc,_), !Lt(x,loc,_).
LtD(x,loc,n) :- Lt(x,loc,n).
LtD(x,loc,n) :- LtD(x,locI,n), control_flow(locI,loc), !Lt(x,loc,_), !GtEq(x,loc,_).
NotEqD(x,loc,n) :- NotEq(x,loc,n).
NotEqD(x,loc,n) :- NotEqD(x,locI,n), control_flow(locI,loc), !NotEq(x,loc,_), !Eq(x,loc,_).
EqD(x,loc,n) :- Eq(x,loc,n).
EqD(x,loc,n) :- EqD(x,locI,n), control_flow(locI,loc), !Eq(x,loc,_), !NotEq(x,loc,_).
EXIT(loc) :- Return(_,loc).
AF_EXIT_T(interm_state,loc) :- AF_EXIT_T(tempOne,loc), !EXIT(tempOne), control_flow(tempOne,interm_state).
AF_EXIT_T(interm_state,loc) :- !EXIT(loc), control_flow(loc,interm_state).
AF_EXIT_S(loc) :- !EXIT(loc), control_flow(loc,tempOne), AF_EXIT_S(tempOne).
AF_EXIT_S(loc) :- AF_EXIT_T(loc,loc).
AF_EXIT(loc) :- State(loc), !AF_EXIT_S(loc).
AF_EXIT_Final(loc) :- Start(loc), AF_EXIT(loc), !NotTotal(loc).
.output GtEqVar
.output LtVar
.output LtEq
.output GtEq
.output Gt
.output Lt
.output NotEq
.output Eq
.output Start
.output State
.output flow
.output Return
.output AF_EXIT_Final(IO=stdout)

/* Other information 

//-- Facts for Procedure <__VERIFIER_nondet_int> 

//-- Facts for Procedure <ff_subtitles_next_line> 

Flow(1,2). //@12:1-13:3
Flow(13,14). //@20:3-20:3
Flow(14,15). //@20:3-21:1
Flow(12,13). //@18:3-20:3
Flow(9,16). //@18:7-18:7
Flow(9,10). //@18:7-18:7
Flow(10,11). //@18:7-19:5
Flow(16,12). //@18:7-18:3
Flow(11,12). //@19:5-18:3
Flow(8,9). //@15:3-18:7
Flow(4,17). //@15:7-15:7
Flow(4,5). //@15:7-15:7
Flow(5,6). //@15:7-16:6
Flow(17,8). //@15:7-15:3
Flow(7,8). //@17:6-15:3
Flow(6,7). //@16:6-17:6
Flow(3,4). //@14:3-15:7
Flow(2,3). //@13:3-14:3
Stmt_Decl(2,[ICall(_fun___VERIFIER_nondet_int,,n$14),IStore(&n,n$14)]). // @13:3
Stmt_BinaryOperatorStmt(3,Assign,[ILoad(&ptr,n$12),ILoad(&n,n$13),IStore(&ptr,(n$12 + n$13))]). // @14:3
Stmt_UnaryOperator(6,[ILoad(&ptr,n$9),IStore(&ptr,(n$9 + 1))]). // @16:6
Stmt_UnaryOperator(7,[ILoad(&n,n$8),IStore(&n,(n$8 + 1))]). // @17:6
PruneNode(17,false,[Prune(!(n$7 == 13), false)]). // @15:7
PruneNode(5,true,[Prune((n$7 == 13), true)]). // @15:7
Stmt_BinaryOperatorStmt(4,EQ,[ILoad(&ptr,n$6),ILoad(n$6,n$7)]). // @15:7
Join(8,[]).  // @15:3
Stmt_UnaryOperator(11,[ILoad(&n,n$3),IStore(&n,(n$3 + 1))]). // @19:5
PruneNode(16,false,[Prune(!(n$2 == 10), false)]). // @18:7
PruneNode(10,true,[Prune((n$2 == 10), true)]). // @18:7
Stmt_BinaryOperatorStmt(9,EQ,[ILoad(&ptr,n$1),ILoad(n$1,n$2)]). // @18:7
Join(12,[]).  // @18:3
Stmt_Return(14,[IStore(&return,n$0)]). // @20:3
Stmt_Return(13,[ILoad(&n,n$0)]). // @20:3
Exit(15).  // @21:1
Start(1). // @12:1
//-- Facts for Procedure <main> 

Flow(1,18). //@23:1-26:5
Flow(13,15). //@37:5-38:1
Flow(14,12). //@30:5-30:12
Flow(12,10). //@30:12-30:12
Flow(12,9). //@30:12-30:12
Flow(9,7). //@30:12-32:9
Flow(10,13). //@30:12-37:5
Flow(16,14). //@34:9-30:5
Flow(11,4). //@34:13-34:13
Flow(11,8). //@34:13-34:13
Flow(8,5). //@34:13-35:9
Flow(4,16). //@34:13-34:9
Flow(5,15). //@35:9-38:1
Flow(17,11). //@33:9-34:13
Flow(7,17). //@32:9-33:9
Flow(6,14). //@28:5-30:5
Flow(3,21). //@28:9-28:9
Flow(3,2). //@28:9-28:9
Flow(2,20). //@28:9-29:9
Flow(21,22). //@28:9-28:18
Flow(22,24). //@28:18-28:18
Flow(22,23). //@28:18-28:18
Flow(23,20). //@28:18-29:9
Flow(24,6). //@28:18-28:5
Flow(20,15). //@29:9-38:1
Flow(19,3). //@27:5-28:9
Flow(18,19). //@26:5-27:5
Stmt_Decl(18,[ICall(_fun___VERIFIER_nondet_int,,n$16),IStore(&b,n$16)]). // @26:5
Stmt_Decl(19,[ICall(_fun___VERIFIER_nondet_int,,n$15),IStore(&end,n$15)]). // @27:5
Stmt_Return(20,[IStore(&return,0)]). // @29:9
PruneNode(24,false,[Prune(!(n$12 < 0), false)]). // @28:18
PruneNode(23,true,[Prune((n$12 < 0), true)]). // @28:18
Stmt_BinaryOperatorStmt(22,LT,[ILoad(&end,n$12)]). // @28:18
PruneNode(21,false,[Prune(!(n$11 < 0), false)]). // @28:9
PruneNode(2,true,[Prune((n$11 < 0), true)]). // @28:9
Stmt_BinaryOperatorStmt(3,LT,[ILoad(&b,n$11)]). // @28:9
Join(6,[]).  // @28:5
Stmt_BinaryOperatorStmt(7,Assign,[ILoad(&b,n$8),ICall(_fun_ff_subtitles_next_line,n$8,n$9),IStore(&inc,n$9)]). // @32:9
Stmt_BinaryOperatorStmt(17,Assign,[ILoad(&b,n$6),ILoad(&inc,n$7),IStore(&b,(n$6 + n$7))]). // @33:9
Stmt_Return(5,[IStore(&return,0)]). // @35:9
PruneNode(4,false,[Prune(!(n$2 >= (n$3 - 4)), false)]). // @34:13
PruneNode(8,true,[Prune((n$2 >= (n$3 - 4)), true)]). // @34:13
Stmt_BinaryOperatorStmt(11,GE,[ILoad(&b,n$2),ILoad(&end,n$3)]). // @34:13
Join(16,[]).  // @34:9
PruneNode(10,false,[Prune(!(n$0 < n$1), false)]). // @30:12
PruneNode(9,true,[Prune((n$0 < n$1), true)]). // @30:12
Stmt_BinaryOperatorStmt(12,LT,[ILoad(&b,n$0),ILoad(&end,n$1)]). // @30:12
Join(14,[]).  // @30:5
Stmt_Return(13,[IStore(&return,0)]). // @37:5
Exit(15).  // @38:1
Start(1). // @23:1
*/

