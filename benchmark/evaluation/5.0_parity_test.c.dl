/*(Start())@0 路 (x=2)@1 路 (([x>=2]@3 路 (([Even("x")]@5 路 (y=1)@6 路 ((Return(0))@8)^w) \/ ([!(Even("x"))]@10 路 (y=0)@11 路 ((Return(0))@8)^w))) \/ ([!(x>=2)]@12 路 (y=0)@11 路 (Join())@7 路 ((Return(0))@8)^w))*/
/*(Start())@0 路 (x=2)@1 路 (([x>=2]@13 路 (([Even("x")]@14 路 (y=1)@15 路 ((Return(0))@16)^w) \/ ([!(Even("x"))]@17 路 (y=0)@18 路 ((Return(0))@19)^w))) \/ ([!(x>=2)]@20 路 (y=0)@21 路 (Join())@22 路 ((Return(0))@23)^w)) 路  */

flow(0,1).
flow(16,16).
flow(19,19).
flow(22,23).
flow(23,23).
Start(0).
Even("x",0).
GtEq("x",0,2).
Odd("x",0).
Lt("x",0,2).
State(0).
GtEq("x",1,2).
State(14).
Eq("y",15,1).
State(15).
Return(0,16).
State(16).
State(13).
State(17).
State(18).
Return(0,19).
State(19).
State(1).
State(20).
State(21).
State(22).
Return(0,23).
State(23).
control_flow(1,13) :- GtEqD("x",1,2).
control_flow(13,14) :- GtEqD("x",13,2), EvenD("x",13).
control_flow(14,15) :- GtEqD("x",14,2), EvenD("x",14).
control_flow(15,16) :- GtEqD("x",15,2), EvenD("x",15).
control_flow(13,17) :- GtEqD("x",13,2).
control_flow(17,18) :- GtEqD("x",17,2).
control_flow(18,19) :- GtEqD("x",18,2).
control_flow(1,20) :- LtD("x",1,2).
control_flow(20,21) :- LtD("x",20,2).
control_flow(21,22) :- LtD("x",21,2).
//AF("y"=1)
.decl Start(x:number)
.decl State(x:number)
.decl flow(x:number,y:number)
.decl control_flow(x:number,y:number)
.decl transFlow(x:number,y:number)
.decl NotTotal(loc:number)
.decl Return(n0:number,n1:number)
.decl Eq(x:symbol,loc:number,n:number)
.decl Lt(x:symbol,loc:number,n:number)
.decl Odd(x:symbol,loc:number)
.decl GtEq(x:symbol,loc:number,n:number)
.decl Even(x:symbol,loc:number)
.decl LtD(x:symbol,loc:number,n:number)
.decl EvenD(x:symbol,loc:number)
.decl GtEqD(x:symbol,loc:number,n:number)
.decl y_eq_1(loc:number)
.decl AF_y_eq_1_T(interm_state:number,loc:number)
.decl AF_y_eq_1_S(loc:number)
.decl AF_y_eq_1(loc:number)
.decl AF_y_eq_1_Final(loc:number)transFlow(x,y) :- control_flow(x,y).
transFlow(x,z) :- control_flow(x,y), transFlow(y,z).
NotTotal(loc) :- State(loc), !control_flow(loc,_).
NotTotal(loc) :- NotTotal(locI), control_flow(loc,locI).
control_flow(x,y) :- flow(x,y).
LtD(x,loc,n) :- Lt(x,loc,n).
LtD(x,loc,n) :- LtD(x,locI,n), control_flow(locI,loc), !Lt(x,loc,_), !GtEq(x,loc,_).
EvenD(x,loc) :- Even(x,loc).
EvenD(x,loc) :- EvenD(x,locI), control_flow(locI,loc), !Even(x,loc), !Odd(x,loc).
GtEqD(x,loc,n) :- GtEq(x,loc,n).
GtEqD(x,loc,n) :- GtEqD(x,locI,n), control_flow(locI,loc), !GtEq(x,loc,_), !Lt(x,loc,_).
y_eq_1(loc) :- State(loc), Eq("y",loc,1).
AF_y_eq_1_T(interm_state,loc) :- AF_y_eq_1_T(tempOne,loc), !y_eq_1(tempOne), control_flow(tempOne,interm_state).
AF_y_eq_1_T(interm_state,loc) :- !y_eq_1(loc), control_flow(loc,interm_state).
AF_y_eq_1_S(loc) :- !y_eq_1(loc), control_flow(loc,tempOne), AF_y_eq_1_S(tempOne).
AF_y_eq_1_S(loc) :- AF_y_eq_1_T(loc,loc).
AF_y_eq_1(loc) :- State(loc), !AF_y_eq_1_S(loc).
AF_y_eq_1_Final(loc) :- Start(loc), AF_y_eq_1(loc), !NotTotal(loc).
.output Eq
.output Lt
.output Odd
.output GtEq
.output Even
.output Start
.output State
.output flow
.output Return
.output AF_y_eq_1_Final(IO=stdout)

