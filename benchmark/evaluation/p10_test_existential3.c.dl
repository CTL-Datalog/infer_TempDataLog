/*(Join())@14*/

flow(14,14).
State(14).

/*(Start())@23 · (r=0)@24 · (([x<=0]@25 · (EXIT())@26) \/ ((((([x>0]@27 · [⊤]@28 · (x=0)@29 · (x=(x-1))@30 · (temp=_)@31 · (r=1)@32 · (EXIT())@33) \/ ((⏊)^w))) \/ ((([x>0]@34 · [⊤]@35 · (x=0)@36 · (x=(x-1))@37 · (temp=_)@38 · (EXIT())@39) \/ ((⏊)^w))))))*/

flow(23,24).
flow(26,26).
flow(33,33).
flow(39,39).
flow(24,24).
Start(23).
LtEq("x",23,0).
Gt("x",23,0).
State(23).
State(25).
EXIT(26).
State(26).
State(27).
State(28).
LtEq("x",29,0).
State(29).
LtEq("x",30,0).
State(30).
State(31).
Eq("r",32,1).
State(32).
EXIT(33).
State(33).
State(34).
State(35).
LtEq("x",36,0).
State(36).
LtEq("x",37,0).
State(37).
State(38).
EXIT(39).
State(39).
State(24).
control_flow(24,25) :- LtEqD("x",24,0).
control_flow(25,26) :- LtEqD("x",24,0).
control_flow(24,27) :- GtD("x",24,0).
control_flow(27,28) :- GtD("x",24,0).
control_flow(28,29) :- GtD("x",24,0).
control_flow(29,30) :- GtD("x",24,0).
control_flow(30,31) :- GtD("x",24,0).
control_flow(31,32) :- GtD("x",24,0).
control_flow(32,33) :- GtD("x",24,0).
control_flow(24,34) :- GtD("x",24,0).
control_flow(34,35) :- GtD("x",24,0).
control_flow(35,36) :- GtD("x",24,0).
control_flow(36,37) :- GtD("x",24,0).
control_flow(37,38) :- GtD("x",24,0).
control_flow(38,39) :- GtD("x",24,0).
//EF("r"=1)
.decl Start(x:number)
.decl State(x:number)
.decl flow(x:number,y:number)
.decl control_flow(x:number,y:number)
.decl transFlow(x:number,y:number)
.decl NotTotal(loc:number)
.decl EXIT(n0:number)
.decl NotEq(x:symbol,loc:number,n:number)
.decl Eq(x:symbol,loc:number,n:number)
.decl Gt(x:symbol,loc:number,n:number)
.decl LtEq(x:symbol,loc:number,n:number)
.decl EqD(x:symbol,loc:number,n:number)
.decl GtD(x:symbol,loc:number,n:number)
.decl LtEqD(x:symbol,loc:number,n:number)
.decl r_eq_1(loc:number)
.decl EF_r_eq_1(loc:number)
.decl EF_r_eq_1_Final(loc:number)transFlow(x,y) :- control_flow(x,y).
transFlow(x,z) :- control_flow(x,y), transFlow(y,z).
NotTotal(loc) :- State(loc), !control_flow(loc,_).
NotTotal(loc) :- NotTotal(locI), control_flow(loc,locI).
control_flow(x,y) :- flow(x,y).
EqD(x,loc,n) :- Eq(x,loc,n).
EqD(x,loc,n) :- EqD(x,locI,n), control_flow(locI,loc), !Eq(x,loc,_), !NotEq(x,loc,_).
GtD(x,loc,n) :- Gt(x,loc,n).
GtD(x,loc,n) :- GtD(x,locI,n), control_flow(locI,loc), !Gt(x,loc,_), !LtEq(x,loc,_).
LtEqD(x,loc,n) :- LtEq(x,loc,n).
LtEqD(x,loc,n) :- LtEqD(x,locI,n), control_flow(locI,loc), !LtEq(x,loc,_), !Gt(x,loc,_).
r_eq_1(loc) :- State(loc), EqD("r",loc,1).
EF_r_eq_1(loc) :- control_flow(loc,tempOne), EF_r_eq_1(tempOne).
EF_r_eq_1(loc) :- r_eq_1(loc).
EF_r_eq_1_Final(loc) :- Start(loc), EF_r_eq_1(loc), !NotTotal(loc).
.output NotEq
.output Eq
.output Gt
.output LtEq
.output Start
.output State
.output flow
.output EXIT
.output EF_r_eq_1_Final(IO=stdout)

/* Other information 

//-- Facts for Procedure <__VERIFIER_nondet_int> 

//-- Facts for Procedure <main> 

Flow(12,0). //@17:1-18:5
Flow(1,11). //@20:5-20:12
Flow(11,8). //@20:12-20:12
Flow(11,10). //@20:12-20:12
Flow(10,2). //@20:12-21:9
Flow(8,9). //@20:12-29:1
Flow(7,1). //@23:9-20:5
Flow(4,6). //@23:13-24:13
Flow(5,7). //@23:13-23:9
Flow(6,7). //@24:13-23:9
Flow(3,5). //@22:9-23:13
Flow(3,4). //@22:9-23:13
Flow(2,3). //@21:9-22:9
Flow(0,1). //@18:5-20:5
Stmt_Decl(0,[IStore(&r,0)]). // @18:5
Stmt_BinaryOperatorStmt(2,Assign,[ILoad(&x,n$5),IStore(&x,(n$5 - 1))]). // @21:9
Stmt_Decl(3,[ICall(_fun___VERIFIER_nondet_int,,n$4),IStore(&temp,n$4)]). // @22:9
Stmt_BinaryOperatorStmt(6,Assign,[IStore(&r,1)]). // @24:13
PruneNode(5,false,[ILoad(&temp,n$1),Prune(!n$1, false)]). // @23:13
PruneNode(4,true,[ILoad(&temp,n$1),Prune(n$1, true)]). // @23:13
Join(7,[]).  // @23:9
PruneNode(8,false,[Prune(!(n$0 > 0), false)]). // @20:12
PruneNode(10,true,[Prune((n$0 > 0), true)]). // @20:12
Stmt_BinaryOperatorStmt(11,GT,[ILoad(&x,n$0)]). // @20:12
Join(1,[]).  // @20:5
Exit(9).  // @29:1
Start(12). // @17:1
*/

